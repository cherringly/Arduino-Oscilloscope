<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Serial Oscilloscope</title>
  <!-- Plotly.js for interactive plotting -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    #controls { padding: 10px; background: #f0f0f0; }
    #plot { width: 100%; height: 80vh; }
    button { padding: 8px 12px; margin-right: 10px; }
  </style>
</head>
<body>
  <div id="controls">
    <button id="connect">Connect to Arduino</button>
    <label>Channels:<br>
      <input type="checkbox" class="ch-toggle" data-ch="0" checked> CH1
      <input type="checkbox" class="ch-toggle" data-ch="1" checked> CH2
      <input type="checkbox" class="ch-toggle" data-ch="2" checked> CH3
      <input type="checkbox" class="ch-toggle" data-ch="3" checked> CH4
      <input type="checkbox" class="ch-toggle" data-ch="4" checked> CH5
      <input type="checkbox" class="ch-toggle" data-ch="5" checked> CH6
    </label>
    <span style="margin-left:20px;">Time window (s):
      <input type="number" id="timeWindow" value="5" step="0.1" style="width:60px;">
    </span>
    <span style="margin-left:20px;">Y-min:
      <input type="number" id="yMin" value="0" step="0.1" style="width:60px;">
    </span>
    <span style="margin-left:20px;">Y-max:
      <input type="number" id="yMax" value="5" step="0.1" style="width:60px;">
    </span>
    <button id="applyBounds" style="margin-left:20px;">Set Bounds</button>
  </div>
  <div id="plot"></div>

  <script>
    let port, reader;
    const textDecoder = new TextDecoderStream();
    const MAX_POINTS = 1000;
    const SAMPLE_INTERVAL = 50; // ms between updates
    const NUM_CHANNELS = 6;
    let timeWindow = 5; // seconds
    let yMin = 0, yMax = 5;
    
    // Buffers
    const timeBuffer = [];
    const channelBuffers = Array.from({ length: NUM_CHANNELS }, () => []);
    let startTime = null;
    
    // Initialize Plotly with two channels
    function initPlot() {
      const traces = [];
      for (let i = 0; i < NUM_CHANNELS; i++) {
        traces.push({
          x: [],
          y: [],
          name: `CH${i+1}`,
          mode: 'lines',
          line: { width: 1 }
        });
      }
      const layout = {
        title: 'Web Serial Oscilloscope',
        xaxis: { title: 'Time (s)', showspikes: true, range: [0, timeWindow] },
        yaxis: { title: 'Voltage (V)', showspikes: true, range: [yMin, yMax] },
        legend: { orientation: 'h' }
      };
      Plotly.newPlot('plot', traces, layout);
    }

    // Connect to serial and start reading
    async function connect() {
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });
      const readableStream = port.readable.pipeThrough(textDecoder);
      reader = readableStream.getReader();
      startTime = performance.now();
      readLoop();
      setInterval(updatePlot, SAMPLE_INTERVAL);
    }

    // Read loop: parse lines "v1,v2"
    async function readLoop() {
      let buffer = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += value;
        let lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          const parts = line.trim().split(',');
          if (parts.length >= NUM_CHANNELS) {
            const t = (performance.now() - startTime) / 1000;
            timeBuffer.push(t);
            for (let i = 0; i < channelBuffers.length; i++) {
              const v = parseFloat(parts[i]);
              channelBuffers[i].push(v);
            }
            // Trim buffers
            if (timeBuffer.length > MAX_POINTS) timeBuffer.shift();
            channelBuffers.forEach(buf => { if (buf.length > MAX_POINTS) buf.shift(); });
          }
        }
      }
    }

    // Update Plotly traces
    function updatePlot() {
      for (let i = 0; i < NUM_CHANNELS; i++) {
        const visible = document.querySelector(`.ch-toggle[data-ch=\"${i}\"]`).checked;
        Plotly.restyle('plot', {
          x: [timeBuffer],
          y: [channelBuffers[i]],
          visible: visible ? true : 'legendonly'
        }, [i]);
      }
      const now = timeBuffer.length ? timeBuffer[timeBuffer.length - 1] : 0;
      Plotly.relayout('plot', {
        'xaxis.range': [Math.max(0, now - timeWindow), now]
      });
    }

    document.getElementById('connect').addEventListener('click', () => {
      connect().catch(err => console.error(err));
    });

    Array.from(document.querySelectorAll('.ch-toggle')).forEach(cb => {
      cb.addEventListener('change', updatePlot);
    });

    document.getElementById('applyBounds').addEventListener('click', () => {
      timeWindow = parseFloat(document.getElementById('timeWindow').value);
      yMin = parseFloat(document.getElementById('yMin').value);
      yMax = parseFloat(document.getElementById('yMax').value);
      Plotly.relayout('plot', {
        'yaxis.range': [yMin, yMax]
      });
    });

    initPlot();
  </script>
</body>
</html>